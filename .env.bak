require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
const dns = require('dns').promises;
const net = require('net');
const https = require('https');

// Inicializa o bot com o token
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });

// Fun√ß√£o para verificar se um IP pertence √† Cloudflare
async function isCloudflare(ip) {
    try {
        const response = await axios.get('https://www.cloudflare.com/ips-v4');
        const cloudflareRanges = response.data.split('\n').filter(Boolean);
        
        return cloudflareRanges.some(range => {
            const [network, bits] = range.split('/');
            const mask = ~((1 << (32 - bits)) - 1);
            const ipParts = ip.split('.').map(Number);
            const networkParts = network.split('.').map(Number);
            
            const ipNum = (ipParts[0] << 24) + (ipParts[1] << 16) + (ipParts[2] << 8) + ipParts[3];
            const networkNum = (networkParts[0] << 24) + (networkParts[1] << 16) + (networkParts[2] << 8) + networkParts[3];
            
            return (ipNum & mask) === (networkNum & mask);
        });
    } catch (error) {
        console.error('Erro ao verificar Cloudflare:', error);
        return false;
    }
}

// Fun√ß√£o para verificar outras CDNs comuns
async function checkOtherCDNs(ip) {
    const cdnPatterns = {
        'Akamai': /(akamai|akam)/i,
        'Fastly': /(fastly)/i,
        'Amazon CloudFront': /(cloudfront|amazon)/i,
        'Google Cloud CDN': /(google|googleusercontent)/i,
        'Microsoft Azure CDN': /(azure|msedge)/i
    };

    try {
        const hostnames = await dns.reverse(ip);
        
        for (const [cdn, pattern] of Object.entries(cdnPatterns)) {
            if (hostnames.some(hostname => pattern.test(hostname))) {
                return { cdn };
            }
        }
        
        return { cdn: null };
    } catch (error) {
        console.error('Erro ao verificar outras CDNs:', error);
        return { cdn: null };
    }
}

// Fun√ß√£o para obter informa√ß√µes de localiza√ß√£o do IP
async function getIPLocation(ip) {
    try {
        const response = await axios.get(`http://ip-api.com/json/${ip}`);
        return response.data;
    } catch (error) {
        console.error('Erro ao obter localiza√ß√£o do IP:', error);
        return null;
    }
}

// Fun√ß√£o para verificar porta
function checkPort(host, port) {
    return new Promise((resolve) => {
        const socket = new net.Socket();
        socket.setTimeout(5000);

        socket.on('connect', () => {
            socket.destroy();
            resolve(true);
        });

        socket.on('error', () => {
            socket.destroy();
            resolve(false);
        });

        socket.on('timeout', () => {
            socket.destroy();
            resolve(false);
        });

        socket.connect(port, host);
    });
}

// Fun√ß√£o para verificar certificado SSL
async function checkSSL(domain) {
    return new Promise((resolve) => {
        const options = {
            host: domain,
            port: 443,
            method: 'GET',
            rejectUnauthorized: false,
        };

        const req = https.request(options, (res) => {
            const cert = res.socket.getPeerCertificate();
            resolve({
                issuer: cert.issuer?.O || 'N/A',
                validTo: new Date(cert.valid_to).toLocaleDateString('pt-BR'),
                validFrom: new Date(cert.valid_from).toLocaleDateString('pt-BR')
            });
        });

        req.on('error', () => {
            resolve(null);
        });

        req.end();
    });
}

// Fun√ß√£o para verificar certificado SNI
async function checkSNICertificate(domain) {
    return new Promise((resolve) => {
        const options = {
            host: domain,
            port: 443,
            method: 'GET',
            servername: domain, // Isso for√ßa o uso de SNI
            rejectUnauthorized: false,
        };

        const req = https.request(options, (res) => {
            const cert = res.socket.getPeerCertificate();
            resolve({
                issuer: cert.issuer?.O || 'N/A',
                validTo: new Date(cert.valid_to).toLocaleDateString('pt-BR'),
                validFrom: new Date(cert.valid_from).toLocaleDateString('pt-BR'),
                subjectAltNames: cert.subjectaltname ? cert.subjectaltname.split(', ').map(san => san.replace(/DNS:|IP Address:/g, '')) : [],
                subject: cert.subject?.CN || 'N/A'
            });
        });

        req.on('error', () => {
            resolve(null);
        });

        req.end();
    });
}

// Fun√ß√£o para resolver dom√≠nio para IP
async function resolveDomain(domain) {
    try {
        const ips = await dns.resolve4(domain);
        return ips;
    } catch (error) {
        console.error('Erro ao resolver dom√≠nio:', error);
        return null;
    }
}

// Fun√ß√£o para verificar status HTTP
async function checkHttpStatus(domain) {
    const urls = [
        `https://${domain}`,
        `http://${domain}`
    ];

    for (const url of urls) {
        try {
            const response = await axios.get(url, {
                maxRedirects: 5,
                timeout: 5000,
                validateStatus: false
            });
            return {
                url,
                status: response.status,
                protocol: url.split(':')[0].toUpperCase()
            };
        } catch (error) {
            console.error(`Erro ao verificar ${url}:`, error.message);
            continue;
        }
    }
    return null;
}

// Fun√ß√£o para obter emoji do status HTTP
function getStatusEmoji(status) {
    if (status >= 200 && status < 300) return '‚úÖ';
    if (status >= 300 && status < 400) return '‚Ü™Ô∏è';
    if (status >= 400 && status < 500) return '‚ö†Ô∏è';
    if (status >= 500) return '‚ùå';
    return '‚ùì';
}

// Fun√ß√£o para obter descri√ß√£o do status HTTP
function getStatusDescription(status) {
    const statusDescriptions = {
        200: 'OK',
        201: 'Created',
        301: 'Moved Permanently',
        302: 'Found',
        304: 'Not Modified',
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        500: 'Internal Server Error',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        504: 'Gateway Timeout'
    };
    return statusDescriptions[status] || 'Unknown Status';
}

// Fun√ß√£o para verificar se a mensagem √© de um grupo
function isGroupMessage(msg) {
    return msg.chat.type === 'group' || msg.chat.type === 'supergroup';
}

// Comando /start
bot.onText(/\/start(@\w+)?$/, (msg) => {
    const chatId = msg.chat.id;
    const isGroup = isGroupMessage(msg);
    const helpMessage = `ü§ñ Bem-vindo ao VPN Checker Bot!

Comandos dispon√≠veis:
${isGroup ? '/check@scannerssh_bot [dom√≠nio]' : '/check [dom√≠nio]'} - Verifica informa√ß√µes do dom√≠nio
${isGroup ? '/help@scannerssh_bot' : '/help'} - Mostra esta mensagem de ajuda

Exemplo:
${isGroup ? '/check@scannerssh_bot google.com' : '/check google.com'}`;
    
    bot.sendMessage(chatId, helpMessage);
});

// Comando /help
bot.onText(/\/help(@\w+)?$/, (msg) => {
    const chatId = msg.chat.id;
    const isGroup = isGroupMessage(msg);
    const helpMessage = `ü§ñ VPN Checker Bot - Comandos:

${isGroup ? '/check@scannerssh_bot [dom√≠nio]' : '/check [dom√≠nio]'} - Verifica informa√ß√µes do dom√≠nio
${isGroup ? '/help@scannerssh_bot' : '/help'} - Mostra esta mensagem de ajuda

Exemplo:
${isGroup ? '/check@scannerssh_bot google.com' : '/check google.com'}`;
    
    bot.sendMessage(chatId, helpMessage);
});

// Fun√ß√£o para validar dom√≠nio
function isValidDomain(domain) {
    const domainPattern = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    return domainPattern.test(domain);
}

// Fun√ß√£o para analisar IP
async function analyzeIP(ip) {
    const isCloudflareIP = await isCloudflare(ip);
    const { cdn: otherCDN } = await checkOtherCDNs(ip);
    
    if (isCloudflareIP) {
        return 'Cloudflare';
    } else if (otherCDN) {
        return otherCDN;
    }
    return null;
}

// Fun√ß√£o para verificar servidor em diferentes regi√µes
async function checkServerRegions(domain) {
    const regions = {
        'Am√©rica do Norte': 'https://us-east.cloudflare-speedtest.com',
        'Europa': 'https://eu-central.cloudflare-speedtest.com',
        '√Åsia': 'https://asia-east.cloudflare-speedtest.com',
        'Am√©rica do Sul': 'https://sa-east.cloudflare-speedtest.com'
    };

    const results = {};
    for (const [region, proxyUrl] of Object.entries(regions)) {
        try {
            const response = await axios.get(`${proxyUrl}/check?domain=${domain}`, {
                timeout: 5000,
                validateStatus: false
            });
            results[region] = response.status < 400;
        } catch (error) {
            results[region] = false;
        }
    }
    return results;
}

// Fun√ß√£o para verificar tipo de hosting
async function checkHostingType(ip) {
    try {
        const response = await axios.get(`https://ipapi.co/${ip}/json/`);
        const data = response.data;
        
        // An√°lise do tipo de hosting baseado em padr√µes comuns
        const hostingPatterns = {
            'AWS': /(amazon|aws)/i,
            'Google Cloud': /(google|googlecloud)/i,
            'Azure': /(microsoft|azure|msft)/i,
            'DigitalOcean': /(digitalocean)/i,
            'Linode': /(linode)/i,
            'OVH': /(ovh)/i,
            'Vultr': /(vultr)/i,
            'Hetzner': /(hetzner)/i
        };

        for (const [provider, pattern] of Object.entries(hostingPatterns)) {
            if (pattern.test(data.org.toLowerCase())) {
                return {
                    provider,
                    type: 'VPS/Cloud'
                };
            }
        }

        // Verifica√ß√£o de datacenter
        if (/datacenter|hosting|cloud/i.test(data.org)) {
            return {
                provider: data.org,
                type: 'Datacenter'
            };
        }

        return {
            provider: data.org,
            type: 'Dedicado/Outro'
        };
    } catch (error) {
        console.error('Erro ao verificar tipo de hosting:', error);
        return null;
    }
}

// Fun√ß√£o para verificar suporte a protocolos de criptografia
async function checkCryptoProtocols(domain) {
    return new Promise((resolve) => {
        const options = {
            host: domain,
            port: 443,
            method: 'GET',
            rejectUnauthorized: false,
        };

        const req = https.request(options, (res) => {
            const protocols = {
                tls: res.socket.getProtocol(),
                ciphers: res.socket.getCipher(),
                cert: res.socket.getPeerCertificate()
            };

            // An√°lise de seguran√ßa
            const security = {
                hasModernTLS: ['TLSv1.2', 'TLSv1.3'].includes(protocols.tls),
                hasStrongCipher: protocols.ciphers?.name?.includes('AES'),
                hasPFS: protocols.ciphers?.name?.includes('ECDHE'),
                securityLevel: 'Desconhecido'
            };

            // Determina n√≠vel de seguran√ßa
            if (security.hasModernTLS && security.hasStrongCipher && security.hasPFS) {
                security.securityLevel = 'Alto';
            } else if (security.hasModernTLS && (security.hasStrongCipher || security.hasPFS)) {
                security.securityLevel = 'M√©dio';
            } else {
                security.securityLevel = 'Baixo';
            }

            resolve(security);
        });

        req.on('error', () => {
            resolve({
                hasModernTLS: false,
                hasStrongCipher: false,
                hasPFS: false,
                securityLevel: 'Indispon√≠vel'
            });
        });

        req.end();
    });
}

// Fun√ß√£o para testar payloads
async function testPayloads(domain, proxyIP) {
    const payloads = {
        // Payloads Vivo
        'Vivo WSS': {
            method: 'GET',
            path: '/',
            headers: {
                'Host': domain,
                'Upgrade': 'websocket',
                'Connection': 'Upgrade',
                'Sec-WebSocket-Key': 'SGVsbG8sIHdvcmxkIQ=='
            }
        },
        'Vivo Direct': {
            method: 'GET',
            path: '/',
            headers: {
                'Host': domain,
                'Connection': 'Upgrade',
                'Upgrade': 'Websocket',
                'X-Real-IP': '127.0.0.1',
                'User-Agent': 'Upgrade'
            }
        },
        'Vivo Proxy': {
            method: 'GET',
            path: `http://${domain}/`,
            headers: {
                'Host': domain,
                'X-Online-Host': domain,
                'X-Forward-Host': domain,
                'Connection': 'Keep-Alive'
            }
        },
        'Vivo Continue': {
            method: 'POST',
            path: '/',
            headers: {
                'Host': domain,
                'Expect': '100-continue',
                'Content-Length': '1024',
                'Content-Type': 'application/x-www-form-urlencoded',
                'Connection': 'Keep-Alive',
                'X-Online-Host': domain,
                'X-Forward-Host': domain,
                'X-Forwarded-For': '127.0.0.1',
                'User-Agent': 'Googlebot/2.1',
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate',
                'Cache-Control': 'no-cache'
            }
        },

        // Payloads TIM
        'TIM Direct': {
            method: 'CONNECT',
            path: '/',
            headers: {
                'Host': domain,
                'X-Online-Host': domain,
                'Connection': 'Keep-Alive'
            }
        },
        'TIM Proxy': {
            method: 'GET',
            path: '/',
            headers: {
                'Host': domain,
                'X-Real-IP': '127.0.0.1',
                'Connection': 'Keep-Alive',
                'Proxy-Connection': 'Keep-Alive'
            }
        },
        'TIM Upgrade': {
            method: 'GET',
            path: '/',
            headers: {
                'Host': domain,
                'Upgrade': 'websocket',
                'Connection': 'Upgrade',
                'Sec-WebSocket-Protocol': 'TIM'
            }
        },
        'TIM Continue': {
            method: 'POST',
            path: '/',
            headers: {
                'Host': domain,
                'Expect': '100-continue',
                'Content-Length': '1024',
                'Content-Type': 'application/x-www-form-urlencoded',
                'Connection': 'Keep-Alive',
                'X-Online-Host': domain,
                'Proxy-Connection': 'Keep-Alive',
                'X-Forward-Host': domain,
                'X-Forwarded-For': '127.0.0.1',
                'User-Agent': 'Googlebot/2.1',
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate',
                'Cache-Control': 'no-cache',
                'X-T-Forward-For': '127.0.0.1',
                'X-Real-Host': domain
            }
        },

        // Payload Split ACL
        'Split ACL': {
            method: 'ACL',
            path: '/',
            headers: {
                'Host': domain,
                'Expect': '100-continue',
                'Connection': 'Upgrade',
                'Proxy-Connection': 'Keep-Alive',
                'Upgrade': 'websocket',
                'X-Forward-Protocol': 'https',
                'X-Forwarded-For': '127.0.0.1',
                'User-Agent': 'Googlebot/2.1'
            }
        },
        'Split Direct': {
            method: 'CONNECT',
            path: `/${domain}:443`,
            headers: {
                'Host': domain,
                'Connection': 'Keep-Alive',
                'Proxy-Connection': 'Keep-Alive',
                'X-Online-Host': domain
            }
        },

        // Payloads Gerais
        'CONNECT Direct': {
            method: 'CONNECT',
            path: `${domain}:443`,
            headers: {
                'Host': domain,
                'X-Online-Host': domain,
                'Connection': 'Keep-Alive',
                'Proxy-Connection': 'Keep-Alive'
            }
        },
        'SSL + Upgrade': {
            method: 'GET',
            path: '/',
            headers: {
                'Host': domain,
                'Upgrade': 'websocket',
                'Connection': 'Upgrade,Keep-Alive',
                'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',
                'Sec-WebSocket-Version': '13',
                'Sec-WebSocket-Protocol': 'chat'
            }
        },
        'Real Host': {
            method: 'GET',
            path: '/',
            headers: {
                'Host': domain,
                'X-Real-IP': '127.0.0.1',
                'X-Forwarded-For': '127.0.0.1',
                'Connection': 'Keep-Alive',
                'Proxy-Connection': 'Keep-Alive'
            }
        },
        'Continue Test': {
            method: 'POST',
            path: '/',
            headers: {
                'Host': domain,
                'Expect': '100-continue',
                'Content-Length': '1024',
                'Content-Type': 'application/x-www-form-urlencoded',
                'Connection': 'Keep-Alive'
            }
        }
    };

    // Adiciona op√ß√µes espec√≠ficas para o proxy quando necess√°rio
    const proxyOptions = {
        host: domain,         // Usa o dom√≠nio fornecido como host
        port: 80,            // Porta padr√£o HTTP
        proxyHost: proxyIP,  // Usa o IP fornecido como proxy
        proxyPort: 80,       // Porta do proxy
        dns: ['8.8.8.8', '8.8.4.4'] // Servidores DNS
    };

    const results = {};
    
    for (const [name, payload] of Object.entries(payloads)) {
        try {
            const options = {
                host: name.includes('Split') ? proxyOptions.proxyHost : domain,
                port: name.includes('Split') ? proxyOptions.proxyPort : 443,
                method: payload.method,
                path: name.includes('Split') ? `http://${domain}${payload.path}` : payload.path,
                headers: {
                    ...payload.headers,
                    'Host': domain
                },
                rejectUnauthorized: false,
                timeout: 5000,
                lookup: name.includes('Split') ? (hostname, options, callback) => {
                    // Usa os DNS especificados para resolu√ß√£o
                    dns.resolve4(hostname, { servers: proxyOptions.dns }, (err, addresses) => {
                        callback(null, addresses ? addresses[0] : null, 4);
                    });
                } : undefined
            };

            const result = await new Promise((resolve) => {
                const req = https.request(options);
                
                req.on('response', (res) => {
                    resolve({
                        status: res.statusCode,
                        success: res.statusCode === 101 || res.statusCode === 200 || res.statusCode === 100,
                        headers: res.headers
                    });
                });

                req.on('continue', () => {
                    resolve({
                        status: 100,
                        success: true,
                        headers: { 
                            'status': '100 Continue',
                            'connection': 'keep-alive',
                            'content-length': '1024'
                        }
                    });
                    req.end();  // Encerra a requisi√ß√£o ap√≥s receber 100-continue
                });

                req.on('upgrade', (res, socket, upgradeHead) => {
                    socket.destroy();
                    res
